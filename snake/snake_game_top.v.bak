// File: snake_game_top.v
// 功能：顶层模块，负责连接所有子模块，管理时钟、按键输入和VGA输出
module snake_game_top(
    input wire CLOCK_50,          // 50MHz clock input
    input wire [3:0] KEY,         // Active-low pushbuttons
    input wire [17:0] SW,         // Switches
    output wire [6:0] HEX0,       // 7-segment displays
    output wire [6:0] HEX1,
    output wire VGA_CLK,          // VGA Clock
    output wire VGA_BLANK_N,      // VGA Blank
    output wire VGA_SYNC_N,       // VGA Sync
    output wire VGA_HS,           // VGA H_SYNC
    output wire VGA_VS,           // VGA V_SYNC
    output wire [7:0] VGA_R,      // VGA Red[7:0]
    output wire [7:0] VGA_G,      // VGA Green[7:0]
    output wire [7:0] VGA_B       // VGA Blue[7:0]
);

    // Internal signals
    wire clk_25MHz;
    wire [9:0] pixel_x;
    wire [9:0] pixel_y;
    wire video_on;
    wire [11:0] score;
    
    // Clock divider for VGA
    clock_divider clk_div(
        .clk_50MHz(CLOCK_50),
        .clk_25MHz(clk_25MHz)
    );
    
    // VGA Controller
    vga_controller vga_ctrl(
        .clk_25MHz(clk_25MHz),
        .reset_n(KEY[0]),
        .hsync(VGA_HS),
        .vsync(VGA_VS),
        .video_on(video_on),
        .pixel_x(pixel_x),
        .pixel_y(pixel_y),
        .p_tick()
    );
    
    // Game Controller
    game_controller game_ctrl(
        .clk_25MHz(clk_25MHz),
        .reset_n(KEY[0]),
        .key_up(!KEY[3]),
        .key_down(!KEY[2]),
        .key_left(!KEY[1]),
        .key_right(!KEY[0]),
        .pixel_x(pixel_x),
        .pixel_y(pixel_y),
        .video_on(video_on),
        .score(score),
        .vga_r(VGA_R),
        .vga_g(VGA_G),
        .vga_b(VGA_B)
    );
    
    // Score display
    score_display score_disp(
        .score(score),
        .hex0(HEX0),
        .hex1(HEX1)
    );
    
    // VGA output assignments
    assign VGA_CLK = clk_25MHz;
    assign VGA_BLANK_N = video_on;
    assign VGA_SYNC_N = 1'b0;

endmodule

////////////////////////////////////////////////////////////////////////////////

// File: clock_divider.v
// 功能：时钟分频模块，将50MHz时钟分频为25MHz
module clock_divider(
    input wire clk_50MHz,
    output reg clk_25MHz
);
    
    reg count;
    
    always @(posedge clk_50MHz)
    begin
        count <= ~count;
        clk_25MHz <= count;
    end
    
endmodule

////////////////////////////////////////////////////////////////////////////////

// File: vga_controller.v
// 功能：VGA控制器，生成VGA时序和像素坐标
module vga_controller(
    input wire clk_25MHz,
    input wire reset_n,
    output wire hsync,
    output wire vsync,
    output wire video_on,
    output wire p_tick,
    output wire [9:0] pixel_x,
    output wire [9:0] pixel_y
);

    // VGA 640x480 sync parameters
    parameter HD = 640;  // horizontal display
    parameter HF = 48;   // h. front porch
    parameter HB = 16;   // h. back porch
    parameter HR = 96;   // h. retrace
    parameter VD = 480;  // vertical display
    parameter VF = 10;   // v. front porch
    parameter VB = 33;   // v. back porch
    parameter VR = 2;    // v. retrace

    // Reg declarations
    reg [9:0] h_count = 0;
    reg [9:0] v_count = 0;

    // Status signals
    wire h_end, v_end;
    wire h_display, v_display;

    // Counter logic
    assign h_end = (h_count == (HD + HF + HB + HR - 1));
    assign v_end = (v_count == (VD + VF + VB + VR - 1));

    // Register operations
    always @(posedge clk_25MHz or negedge reset_n)
    begin
        if (!reset_n)
        begin
            h_count <= 0;
            v_count <= 0;
        end
        else
        begin
            if (h_end)
            begin
                h_count <= 0;
                if (v_end)
                    v_count <= 0;
                else
                    v_count <= v_count + 1;
            end
            else
                h_count <= h_count + 1;
        end
    end

    // Output assignments
    assign h_display = (h_count < HD);
    assign v_display = (v_count < VD);
    assign video_on = h_display && v_display;
    assign hsync = !(h_count >= (HD + HF) && h_count < (HD + HF + HR));
    assign vsync = !(v_count >= (VD + VF) && v_count < (VD + VF + VR));
    assign pixel_x = h_count;
    assign pixel_y = v_count;
    assign p_tick = 1'b1;  // Not used in this implementation

endmodule

////////////////////////////////////////////////////////////////////////////////

// File: game_controller.v
// 功能：游戏控制器，处理蛇的移动、碰撞检测和游戏逻辑
module game_controller(
    input wire clk_25MHz,
    input wire reset_n,
    input wire key_up,
    input wire key_down,
    input wire key_left,
    input wire key_right,
    input wire [9:0] pixel_x,
    input wire [9:0] pixel_y,
    input wire video_on,
    output reg [11:0] score,
    output reg [7:0] vga_r,
    output reg [7:0] vga_g,
    output reg [7:0] vga_b
);

    // Game parameters
    parameter SNAKE_SIZE = 20;     // Size of snake segments
    parameter MAX_LENGTH = 64;     // Maximum length of snake
    parameter GRID_WIDTH = 32;     // Game grid width (640/20)
    parameter GRID_HEIGHT = 24;    // Game grid height (480/20)

    // Snake position arrays
    reg [5:0] snake_x [0:MAX_LENGTH-1];  // X positions
    reg [5:0] snake_y [0:MAX_LENGTH-1];  // Y positions
    reg [5:0] snake_length;              // Current length
    reg [1:0] direction;                 // 0:up, 1:right, 2:down, 3:left

    // Food position
    reg [5:0] food_x;
    reg [5:0] food_y;

    // Game state
    reg game_over;
    reg [19:0] move_counter;
    wire move_tick;

    // Game clock divider
    assign move_tick = (move_counter == 0);

    // Initialize game
    initial begin
        snake_length = 1;
        direction = 1;
        game_over = 0;
        score = 0;
        snake_x[0] = GRID_WIDTH/4;
        snake_y[0] = GRID_HEIGHT/2;
        food_x = (GRID_WIDTH*3)/4;
        food_y = GRID_HEIGHT/2;
    end

    // Movement counter
    always @(posedge clk_25MHz or negedge reset_n) begin
        if (!reset_n) begin
            move_counter <= 0;
        end else begin
            if (move_counter == 1250000) // Adjust for snake speed
                move_counter <= 0;
            else
                move_counter <= move_counter + 1;
        end
    end

    // Direction control
    always @(posedge clk_25MHz or negedge reset_n) begin
        if (!reset_n) begin
            direction <= 1;
        end else if (!game_over) begin
            if (key_up && direction != 2)
                direction <= 0;
            else if (key_right && direction != 3)
                direction <= 1;
            else if (key_down && direction != 0)
                direction <= 2;
            else if (key_left && direction != 1)
                direction <= 3;
        end
    end

    // Snake movement and collision detection
    always @(posedge clk_25MHz or negedge reset_n) begin
        if (!reset_n) begin
            snake_length <= 1;
            game_over <= 0;
            score <= 0;
        end else if (move_tick && !game_over) begin
            // Move snake body
            for (integer i = snake_length-1; i > 0; i = i-1) begin
                snake_x[i] <= snake_x[i-1];
                snake_y[i] <= snake_y[i-1];
            end

            // Move snake head
            case (direction)
                0: snake_y[0] <= (snake_y[0] == 0) ? GRID_HEIGHT-1 : snake_y[0]-1;
                1: snake_x[0] <= (snake_x[0] == GRID_WIDTH-1) ? 0 : snake_x[0]+1;
                2: snake_y[0] <= (snake_y[0] == GRID_HEIGHT-1) ? 0 : snake_y[0]+1;
                3: snake_x[0] <= (snake_x[0] == 0) ? GRID_WIDTH-1 : snake_x[0]-1;
            endcase

            // Food collision check
            if (snake_x[0] == food_x && snake_y[0] == food_y) begin
                if (snake_length < MAX_LENGTH) begin
                    snake_length <= snake_length + 1;
                    score <= score + 1;
                    food_x <= (food_x + 7) % GRID_WIDTH;
                    food_y <= (food_y + 5) % GRID_HEIGHT;
                end
            end

            // Self collision check
            for (integer i = 1; i < snake_length; i = i+1) begin
                if (snake_x[0] == snake_x[i] && snake_y[0] == snake_y[i])
                    game_over <= 1;
            end
        end
    end

    // VGA display logic
    always @* begin
        if (!video_on) begin
            {vga_r, vga_g, vga_b} = 24'h000000;
        end else begin
            // Default background
            {vga_r, vga_g, vga_b} = 24'h000000;

            // Draw snake
            for (integer i = 0; i < snake_length; i = i+1) begin
                if (pixel_x/SNAKE_SIZE == snake_x[i] && 
                    pixel_y/SNAKE_SIZE == snake_y[i]) begin
                    if (i == 0)
                        {vga_r, vga_g, vga_b} = 24'h00FF00; // Green head
                    else
                        {vga_r, vga_g, vga_b} = 24'h008800; // Dark green body
                end
            end

            // Draw food
            if (pixel_x/SNAKE_SIZE == food_x && 
                pixel_y/SNAKE_SIZE == food_y)
                {vga_r, vga_g, vga_b} = 24'hFF0000; // Red food

            // Game over display
            if (game_over && 
                pixel_x >= 240 && pixel_x < 400 &&
                pixel_y >= 200 && pixel_y < 280)
                {vga_r, vga_g, vga_b} = 24'hFF0000;
        end
    end

endmodule

////////////////////////////////////////////////////////////////////////////////

// File: score_display.v
// 功能：分数显示模块，在七段数码管上显示游戏分数
module score_display(
    input wire [11:0] score,
    output reg [6:0] hex0,
    output reg [6:0] hex1
);

    // 7-segment display patterns
    always @* begin
        case(score % 10)
            4'h0: hex0 = 7'b1000000;
            4'h1: hex0 = 7'b1111001;
            4'h2: hex0 = 7'b0100100;
            4'h3: hex0 = 7'b0110000;
            4'h4: hex0 = 7'b0011001;
            4'h5: hex0 = 7'b0010010;
            4'h6: hex0 = 7'b0000010;
            4'h7: hex0 = 7'b1111000;
            4'h8: hex0 = 7'b0000000;
            4'h9: hex0 = 7'b0010000;
            default: hex0 = 7'b1111111;
        endcase

        case(score / 10)
            4'h0: hex1 = 7'b1000000;
            4'h1: hex1 = 7'b1111001;
            4'h2: hex1 = 7'b0100100;
            4'h3: hex1 = 7'b0110000;
            4'h4: hex1 = 7'b0011001;
            4'h5: hex1 = 7'b0010010;
            4'h6: hex1 = 7'b0000010;
            4'h7: hex1 = 7'b1111000;
            4'h8: hex1 = 7'b0000000;
            4'h9: hex1 = 7'b0010000;
            default: hex1 = 7'b1111111;
        endcase
    end

endmodule