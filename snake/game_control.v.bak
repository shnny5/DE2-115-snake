module game_control(
    input clk_25MHz,
    input reset_n,
    input key_up,
    input key_down,
    input key_left,
    input key_right,
    input [9:0] pixel_x,
    input [9:0] pixel_y,
    input video_on,
    output reg [23:0] rgb_reg
);
    // 游戏参数
    parameter MAX_LENGTH = 32;      // 蛇的最大长度（限制在32以确保循环次数合理）
    parameter GRID_SIZE = 20;       // 网格大小
    parameter INIT_LENGTH = 3;      // 初始长度
    parameter DISPLAY_BLOCKS = 32;  // 用于显示的最大块数
    
    // 蛇的位置存储
    reg [9:0] snake_x [0:MAX_LENGTH-1];
    reg [9:0] snake_y [0:MAX_LENGTH-1];
    reg [5:0] snake_length;
    reg [1:0] direction;  // 00:上, 01:下, 10:左, 11:右
    
    // 食物位置
    reg [9:0] food_x;
    reg [9:0] food_y;
    
    // 游戏时钟分频
    reg [24:0] game_clock;
    wire game_tick;
    
    // 游戏状态
    reg game_over;
    
    // 循环计数器
    reg [5:0] i;
    
    // 颜色定义
    parameter BLACK = 24'h000000;
    parameter WHITE = 24'hFFFFFF;
    parameter RED = 24'hFF0000;
    parameter GREEN = 24'h00FF00;
    
    // 游戏时钟生成
    always @(posedge clk_25MHz or negedge reset_n)
    begin
        if(!reset_n)
            game_clock <= 25'b0;
        else
            game_clock <= game_clock + 1'b1;
    end
    
    assign game_tick = (game_clock == 25'd6250000);  // 约0.125秒更新一次
    
    // 方向控制
    always @(posedge clk_25MHz or negedge reset_n)
    begin
        if(!reset_n)
            direction <= 2'b11;  // 初始向右移动
        else if(!game_over) begin
            if(key_up && direction != 2'b01)
                direction <= 2'b00;
            else if(key_down && direction != 2'b00)
                direction <= 2'b01;
            else if(key_left && direction != 2'b11)
                direction <= 2'b10;
            else if(key_right && direction != 2'b10)
                direction <= 2'b11;
        end
    end
    
    // 蛇的移动
    always @(posedge clk_25MHz or negedge reset_n)
    begin
        if(!reset_n) begin
            // 初始化蛇的位置
            snake_x[0] <= 10'd320;
            snake_y[0] <= 10'd240;
            snake_length <= INIT_LENGTH;
            game_over <= 1'b0;
            // 初始化食物位置
            food_x <= 10'd400;
            food_y <= 10'd300;
            i <= 0;
        end
        else if(game_tick && !game_over) begin
            // 移动蛇身
            for(i = 0; i < MAX_LENGTH-1; i = i + 1) begin
                if(i < snake_length-1) begin
                    snake_x[snake_length-1-i] <= snake_x[snake_length-2-i];
                    snake_y[snake_length-1-i] <= snake_y[snake_length-2-i];
                end
            end
            
            // 移动蛇头
            case(direction)
                2'b00: snake_y[0] <= snake_y[0] - GRID_SIZE;  // 上
                2'b01: snake_y[0] <= snake_y[0] + GRID_SIZE;  // 下
                2'b10: snake_x[0] <= snake_x[0] - GRID_SIZE;  // 左
                2'b11: snake_x[0] <= snake_x[0] + GRID_SIZE;  // 右
            endcase
            
            // 检查是否吃到食物
            if((snake_x[0] == food_x) && (snake_y[0] == food_y)) begin
                snake_length <= snake_length + 1'b1;
                // 生成新的食物位置
                food_x <= ((pixel_x + 100) % (640 - GRID_SIZE)) / GRID_SIZE * GRID_SIZE;
                food_y <= ((pixel_y + 100) % (480 - GRID_SIZE)) / GRID_SIZE * GRID_SIZE;
            end
            
            // 检查游戏结束条件
            if(snake_x[0] >= 640 || snake_x[0] < 0 ||
               snake_y[0] >= 480 || snake_y[0] < 0)
                game_over <= 1'b1;
                
            // 检查是否撞到自己
            for(i = 0; i < MAX_LENGTH; i = i + 1) begin
                if(i > 0 && i < snake_length) begin
                    if((snake_x[0] == snake_x[i]) && (snake_y[0] == snake_y[i])) begin
                        game_over <= 1'b1;
                    end
                end
            end
        end
    end
    
    // 显示控制
    reg in_food_area;
    reg [31:0] in_snake_area;
    reg [4:0] block_index;
    
    always @(*) begin
        // 检查是否在食物区域
        in_food_area = ((pixel_x >= food_x) && (pixel_x < food_x + GRID_SIZE) &&
                       (pixel_y >= food_y) && (pixel_y < food_y + GRID_SIZE));
        
        // 检查是否在蛇的区域
        block_index = 0;
        in_snake_area = 0;
        
        for(i = 0; i < DISPLAY_BLOCKS; i = i + 1) begin
            if(i < snake_length) begin
                if((pixel_x >= snake_x[i]) && (pixel_x < snake_x[i] + GRID_SIZE) &&
                   (pixel_y >= snake_y[i]) && (pixel_y < snake_y[i] + GRID_SIZE)) begin
                    in_snake_area[i] = 1;
                    block_index = i;
                end
            end
        end
        
        // 设置显示颜色
        if(!video_on)
            rgb_reg = BLACK;
        else if(game_over)
            rgb_reg = RED;
        else if(in_food_area)
            rgb_reg = RED;
        else if(|in_snake_area)
            rgb_reg = (block_index == 0) ? WHITE : GREEN;
        else
            rgb_reg = BLACK;
    end

endmodule